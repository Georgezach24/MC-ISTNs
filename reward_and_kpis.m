function [r, kpi] = reward_and_kpis(P, stepKPI, actionChanged, hoEvent)
% Συνάρτηση υπολογισμού reward και επιστροφής KPIs του slot.
%
% Στόχος reward (prototype για RL):
%   • Επιβράβευση επιτυχούς URLLC παράδοσης
%   • Ισχυρή ποινή για URLLC failure (deadline miss)
%   • Μικρή θετική συνεισφορά από eMBB throughput
%   • Ποινή για συχνές αλλαγές action (σταθερότητα πολιτικής)
%   • Ποινή για handover γεγονότα (λόγω interruption / signaling cost)
%
% Είσοδοι:
%   - stepKPI: KPIs που προέκυψαν από το serving του slot
%   - actionChanged: boolean (αν άλλαξε action σε σχέση με προηγούμενο slot)
%   - hoEvent: boolean (αν ολοκληρώθηκε HO στο slot)
%
% Έξοδοι:
%   - r: συνολικό reward του slot
%   - kpi: επιστροφή των KPIs (εδώ απλώς passthrough του stepKPI)

% =====================================================================
%                    1) Reward συνιστώσα URLLC
% =====================================================================
% Αν παραδόθηκε πακέτο στο slot:
%   - +1   αν εντός deadline
%   - -10  αν εκτός deadline
% Αν δεν παραδόθηκε πακέτο, συνεισφορά = 0

if stepKPI.URLLC_delivered == 1

    if stepKPI.URLLC_success == 1
        rU = 1.0;      % Επιτυχής URLLC παράδοση
    else
        rU = -10.0;    % Deadline violation (ισχυρή ποινή)
    end

else
    rU = 0.0;          % Δεν υπήρξε παράδοση σε αυτό το slot
end
%----------------------------------------------------------------------

% =====================================================================
%                    2) Reward συνιστώσα eMBB
% =====================================================================
% Μικρή γραμμική επιβράβευση ανάλογη του DL throughput.
% Ο συντελεστής 1e-7 κρατάει το eMBB reward σε μικρή κλίμακα
% σε σχέση με το URLLC (που είναι mission-critical).
rE = 1e-7 * stepKPI.eMBB_bitsDL;
%----------------------------------------------------------------------

% =====================================================================
%                    3) Ποινή για αλλαγή action
% =====================================================================
% Αν η πολιτική αλλάζει συχνά mode (π.χ. TN↔NTN↔DUP),
% επιβάλλεται μικρή ποινή για σταθερότητα/robustness.
penSwitch = -0.1 * double(actionChanged);
%----------------------------------------------------------------------

% =====================================================================
%                    4) Ποινή για handover event
% =====================================================================
% Κάθε ολοκληρωμένο HO επιφέρει ποινή λόγω:
%   - interruption
%   - signaling overhead
%   - πιθανή απώλεια QoS
penHO = -1.0 * double(hoEvent);
%----------------------------------------------------------------------

% =====================================================================
%                    5) Συνολικό reward
% =====================================================================
r = rU + rE + penSwitch + penHO;
%----------------------------------------------------------------------

% Επιστρέφουμε και τα KPIs του slot (χωρίς επιπλέον επεξεργασία)
kpi = stepKPI;

end