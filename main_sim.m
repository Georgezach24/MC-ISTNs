%----------------------------------------------------------------------
% Καθαρισμός workspace και command window πριν την εκτέλεση.
clear; clc;
%----------------------------------------------------------------------

% =====================================================================
%                     Επιλογή Scenarios Προσομοίωσης
% =====================================================================
scenarioList = {'A','C'};  % Λίστα σεναρίων.
%----------------------------------------------------------------------

% =====================================================================
%                     Loop ανά Scenario 
% =====================================================================
for s = 1:numel(scenarioList)

    % --------- Φόρτωση/ορισμός παραμέτρων σεναρίου --------------------
    scenario = scenarioList{s};
    P = default_params(scenario);  % Παράμετροι προσομοίωσης/καναλιού/HO/traffic
    S = init_scenario(P);          % Αρχικοποίηση state + ουρές + logs
    %----------------------------------------------------------------------

    % --------- Προδέσμευση θέσεων δορυφόρων ------------
    % Θα ενημερώνεται σε κάθε slot στο update_positions.
    S.SATx = zeros(1, numel(P.SAT));
    %----------------------------------------------------------------------

    % --------- Αποθήκευση προηγούμενης ενέργειας για penalty ----------
    lastAction = S.action;
    %----------------------------------------------------------------------

    % =================================================================
    %                     Main Loop Προσομοίωσης (ανά slot)
    % =================================================================
    for k = 1:P.T

        % --------- Τρέχων χρόνος προσομοίωσης -------------------------
        S.t = (k-1)*P.dt;   % Χρόνος σε seconds
        %----------------------------------------------------------------------

        % ==============================================================
        % 1) Ενημέρωση Γεωμετρίας & Traffic
        % ==============================================================
        % - Move UE + SAT positions
        % - Generate URLLC packets into FIFO
        S = update_positions(S, P, k);
        S = traffic_step(S, P, k);
        %----------------------------------------------------------------------

        % ==============================================================
        % 2) Υπολογισμός Καναλιού / Link Metrics
        % ==============================================================
        % Υπολογίζονται SINR, Rates, Prop delays για όλους τους candidates
        % και εξάγονται serving τιμές.
        L = compute_links(S, P);
        %----------------------------------------------------------------------

        % ==============================================================
        % 3) Handover update (TN + NTN)
        % ==============================================================
        % Ενημέρωση HO state με:
        % - EWMA filtered SINR
        % - hysteresis + TTT
        % - execution interruption
        [S, hoTN, hoNTN] = handover_update(S, P, L);
        hoEvent = hoTN || hoNTN;   % Flag: αν ολοκληρώθηκε HO (TN ή NTN) στο slot
        %----------------------------------------------------------------------

        % ==============================================================
        % 4) Baseline Policy (Heuristic action selection)
        % ==============================================================
        % Επιλέγουμε modeU (URLLC) και modeE (eMBB) με βάση serving SINR.
        action = S.action;  % Ξεκινάμε από την προηγούμενη ενέργεια (stateful baseline)
        %----------------------------------------------------------------------

        % --------- Κριτήριο "χαμηλού SINR" -----------------------------
        % Αν ένα από τα δύο links είναι σε outage ,
        % για URLLC επιλέγουμε DUP για αξιοπιστία.
        sinrLow = (L.SINR_TN_DL < P.SINRmin) || ...
                  (L.SINR_NTN_DL < P.SINRmin);
        %----------------------------------------------------------------------

        % --------- Επιλογή URLLC mode (modeU) --------------------------
        if sinrLow
            action.modeU = 3; % DUP: διπλή μετάδοση, αρκεί να πετύχει ένα link
        else
            % Αλλιώς: επιλέγουμε το link με το μεγαλύτερο SINR
            if L.SINR_TN_DL >= L.SINR_NTN_DL
                action.modeU = 0; % TN
            else
                action.modeU = 1; % NTN
            end
        end
        %----------------------------------------------------------------------

        % --------- Επιλογή eMBB mode (modeE) ---------------------------
        % Αν ΚΑΙ τα δύο links είναι πάνω από το threshold, κάνουμε SPLIT/aggregation.
        % Αλλιώς: επιλέγουμε το καλύτερο link (TN ή NTN).
        if (L.SINR_TN_DL > P.SINRmin) && ...
           (L.SINR_NTN_DL > P.SINRmin)
            action.modeE = 2; % SPLIT aggregate: άθροιση throughput TN+NTN
        else
            % Επιστρέφει 1 αν NTN καλύτερο, αλλιώς 0 (TN)
            action.modeE = uint8(L.SINR_NTN_DL > L.SINR_TN_DL);
        end
        %----------------------------------------------------------------------

        % --------- Flag: άλλαξε η ενέργεια σε σχέση με προηγούμενο slot -
        actionChanged = (action.modeU ~= lastAction.modeU) || ...
                        (action.modeE ~= lastAction.modeE);
        %----------------------------------------------------------------------

        % ==============================================================
        % 5) Εξυπηρέτηση URLLC + eMBB με βάση το action και HO interruptions
        % ==============================================================
        [S, stepKPI] = apply_action_and_serve(S, P, L, action);
        %----------------------------------------------------------------------

        % ==============================================================
        % 6) Reward + KPI (prototype για RL)
        % ==============================================================
        % Αυτή τη στιγμή το reward δεν χρησιμοποιείται (το πετάμε με ~),
        % αλλά ο υπολογισμός υπάρχει για πιθανή μελλοντική χρήση σε RL training.
        [~, ~] = reward_and_kpis(P, stepKPI, actionChanged, hoEvent);
        %----------------------------------------------------------------------

        % ==============================================================
        % 7) Logging (αποθήκευση ιστορικού ανά slot)
        % ==============================================================
        % --------- Actions --------------------------------------------
        S.log.actionU(k) = uint8(action.modeU);
        S.log.actionE(k) = uint8(action.modeE);
        %----------------------------------------------------------------------

        % --------- Serving SINR ---------------------------------------
        S.log.SINR_TN_DL(k)  = L.SINR_TN_DL;
        S.log.SINR_NTN_DL(k) = L.SINR_NTN_DL;
        %----------------------------------------------------------------------

        % --------- Handover events ------------------------------------
        S.log.hoTN(k)  = hoTN;
        S.log.hoNTN(k) = hoNTN;
        %----------------------------------------------------------------------

        % --------- Serving node indexes + UE position -----------------
        S.log.servBS(k)  = uint8(S.servBS);
        S.log.servSAT(k) = uint8(S.servSAT);
        S.log.ueX(k)     = S.UE.x;
        %----------------------------------------------------------------------

        % --------- URLLC KPIs -----------------------------------------
        S.log.kpi_URLLC_succ(k)  = stepKPI.URLLC_success;
        S.log.kpi_URLLC_delay(k) = stepKPI.URLLC_delay;
        %----------------------------------------------------------------------

        % ==============================================================
        % 8) Ενημέρωση “προηγούμενης” ενέργειας
        % ==============================================================
        lastAction = action; % για actionChanged στο επόμενο slot
        S.action   = action; % αποθήκευση τρέχοντος action στο state
        %----------------------------------------------------------------------

    end % end time slots
    % =================================================================

    % =================================================================
    %                     Αποθήκευση Dataset (.mat)
    % =================================================================
    outFile = sprintf('dataset_%s.mat', scenario); % Όνομα αρχείου εξόδου
    save(outFile, 'P', 'S');                       % Αποθηκεύουμε params + logs/state
    fprintf('Saved %s\n', outFile);                % Μήνυμα επιβεβαίωσης
    %----------------------------------------------------------------------

end % end scenarios
% =====================================================================